continue
classes
db_keys
continue
        tables.map{ |table| ActiveRecord::Base.connection.foreign_keys(table)}.flatten
        }.flatten
          ActiveRecord::Base.connection.foreign_keys(table)
 tables.map{ |table|
continue
foreign_keys
foreign_keys[foreign_key.hash_key]
foreign_keys[foreign_key.hash_key] = foreign_key
          foreign_keys[foreign_key.hash_key] = foreign_key
foreign_key
continue
key.options[:primary_key] == "id" || has_unique_index?(key.to_table, key.options[:primary_key])
column_exists?(key.to_table, key.options[:primary_key])
column_exists?(key.from_table, key.options[:column])
key.options[:column]
V
tables.include?(key.to_table)
(key.from_table)
tables.include?(key.from_table)
tables = connection.tables
continue
current_key = foreign_keys[foreign_key.hash_key]
foreign_keys[foreign_key.hash_key]
current_key
continue
        ]
          )
            # sense from a foreign key perspective, so no :on_delete
            # although belongs_to can specify :dependent, it doesn't make
            :primary_key => primary_key
            :column => column,
            to_table,
            from_table,
          ForeignKeyDefinition.new(
[
        primary_key = (reflection.options[:primary_key] || reflection.klass.primary_key).to_s
column = reflection.send(FOREIGN_KEY).to_s
to_table = reflection.klass.table_name
from_table = klass.table_name
return if reflection.name == :left_side # redundant and unusable reflection automagically created by HABTM
reflection.name
reflection
continue
exit
key.options[:primary_key] == "id"
column_exists?(key.to_table, key.options[:primary_key])
key.options[:column]
column_exists?(key.from_table, key.options[:column])
key.to_table
key.from_table
key
tables.include?(key.from_table)
tables = connection.tables
tables
